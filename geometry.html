<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Geometry Runner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #05060a; /* Dark background */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      user-select: none;
      overflow: hidden;
    }

    #container {
      text-align: center;
    }

    canvas {
      background: radial-gradient(circle at top, #202840 0, #05060a 60%);
      border: 2px solid #26f0ff;
      box-shadow: 0 0 20px #26f0ff55;
      max-width: 100vw;
      max-height: 70vh;
    }

    #info {
      margin-top: 8px;
      font-size: 14px;
      color: #9aa4ff;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="game" width="800" height="400"></canvas>
    <div id="info">
      Tap / Click / Space to jump â€¢ R to restart
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const W = canvas.width;
    const H = canvas.height;

    // Game state
    let lastTime = 0;
    let running = true;
    let gameOver = false;

    // World
    const groundY = H - 60;
    const scrollSpeed = 320; // pixels / second
    const gravity = 1700;    // pixels / second^2
    const jumpVelocity = -650;

    // Player (square) [web:25][web:26]
    const player = {
      x: 120,
      y: groundY - 40,
      size: 40,
      vy: 0,
      canJump: true
    };

    // Obstacles (spikes/blocks) [web:26][web:28]
    const obstacles = [];
    let obstacleTimer = 0;
    const minSpawnTime = 0.8;
    const maxSpawnTime = 1.8;
    let nextSpawnIn = randRange(minSpawnTime, maxSpawnTime);

    // Score
    let score = 0;
    let highScore = 0;

    // Input
    let jumpQueued = false;

    function randRange(a, b) {
      return a + Math.random() * (b - a);
    }

    function resetGame() {
      player.y = groundY - player.size;
      player.vy = 0;
      player.canJump = true;

      obstacles.length = 0;
      obstacleTimer = 0;
      nextSpawnIn = randRange(minSpawnTime, maxSpawnTime);

      score = 0;
      gameOver = false;
      running = true;
    }

    function queueJump() {
      jumpQueued = true;
    }

    // Controls: keyboard + mouse + touch [web:26][web:39]
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameOver) {
          resetGame();
        } else {
          queueJump();
        }
      } else if (e.key === 'r' || e.key === 'R') {
        resetGame();
      }
    });

    canvas.addEventListener('mousedown', () => {
      if (gameOver) {
        resetGame();
      } else {
        queueJump();
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameOver) {
        resetGame();
      } else {
        queueJump();
      }
    }, { passive: false });

    function update(dt) {
      if (!running) return;

      // Queue jump handling
      if (jumpQueued && player.canJump && !gameOver) {
        player.vy = jumpVelocity;
        player.canJump = false;
      }
      jumpQueued = false;

      // Apply gravity [web:39]
      player.vy += gravity * dt;
      player.y += player.vy * dt;

      // Ground collision
      if (player.y + player.size >= groundY) {
        player.y = groundY - player.size;
        player.vy = 0;
        player.canJump = true;
      }

      // Spawn obstacles with varying gaps/heights [web:28][web:34]
      obstacleTimer += dt;
      if (obstacleTimer >= nextSpawnIn) {
        obstacleTimer = 0;
        nextSpawnIn = randRange(minSpawnTime, maxSpawnTime);

        const type = Math.random() < 0.7 ? 'spike' : 'block';
        let width, height;

        if (type === 'spike') {
          width = 30;
          height = randRange(40, 70);
        } else {
          width = randRange(35, 55);
          height = randRange(45, 80);
        }

        obstacles.push({
          x: W + 40,
          y: groundY,
          width,
          height,
          type
        });
      }

      // Move obstacles
      for (const o of obstacles) {
        o.x -= scrollSpeed * dt;
      }

      // Remove off-screen
      while (obstacles.length && obstacles[0].x + obstacles[0].width < -50) {
        obstacles.shift();
      }

      // Collision detection (AABB) [web:28]
      const px = player.x;
      const py = player.y;
      const ps = player.size;

      for (const o of obstacles) {
        const ox = o.x;
        const oy = o.y - o.height;
        const ow = o.width;
        const oh = o.height;

        if (px < ox + ow &&
            px + ps > ox &&
            py < oy + oh &&
            py + ps > oy) {
          running = false;
          gameOver = true;
          if (score > highScore) highScore = score;
          break;
        }
      }

      // Score increases with survival time / distance [web:34]
      if (!gameOver) {
        score += dt * 10;
      }
    }

    function drawBackground() {
      // Simple neon grid background
      ctx.fillStyle = '#05060a';
      ctx.fillRect(0, 0, W, H);

      // Horizontal neon lines
      ctx.strokeStyle = '#202a55';
      ctx.lineWidth = 1;
      const gridSize = 30;
      for (let y = groundY; y > 40; y -= gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Vertical parallax lines
      ctx.strokeStyle = '#131b3d';
      for (let x = 0; x <= W; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
    }

    function drawGround() {
      ctx.fillStyle = '#11172e';
      ctx.fillRect(0, groundY, W, H - groundY);

      ctx.strokeStyle = '#26f0ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(W, groundY);
      ctx.stroke();
    }

    function drawPlayer() {
      // Glowing square
      ctx.fillStyle = '#26f0ff';
      ctx.fillRect(player.x, player.y, player.size, player.size);

      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(player.x + 6, player.y + 6, player.size - 12, player.size - 12);
    }

    function drawObstacles() {
      for (const o of obstacles) {
        if (o.type === 'spike') {
          ctx.fillStyle = '#ff2e63';
          ctx.beginPath();
          ctx.moveTo(o.x, o.y);
          ctx.lineTo(o.x + o.width / 2, o.y - o.height);
          ctx.lineTo(o.x + o.width, o.y);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = '#ff9f1c';
          ctx.fillRect(o.x, o.y - o.height, o.width, o.height);
        }
      }
    }

    function drawHUD() {
      ctx.fillStyle = '#ffffff';
      ctx.font = '18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('Score: ' + Math.floor(score), 20, 30);
      ctx.fillText('Best: ' + Math.floor(highScore), 20, 54);
    }

    function drawGameOver() {
      if (!gameOver) return;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';

      ctx.font = '36px system-ui';
      ctx.fillText('GAME OVER', W / 2, H / 2 - 20);

      ctx.font = '18px system-ui';
      ctx.fillText('Score: ' + Math.floor(score) + '   Best: ' + Math.floor(highScore), W / 2, H / 2 + 16);
      ctx.fillText('Press R or Tap to Restart', W / 2, H / 2 + 48);
    }

    function draw(dt) {
      drawBackground();
      drawGround();
      drawObstacles();
      drawPlayer();
      drawHUD();
      drawGameOver();
    }

    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
      lastTime = timestamp;

      update(dt);
      draw(dt);

      requestAnimationFrame(gameLoop);
    }

    resetGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>